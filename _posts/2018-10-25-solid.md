---
layout: post
title: Principios SOLID
tags: Arquitectura
---

Hola hoy vento con los principios SOLID. Aunque es un tema que conozco, el pasado sábado asistí a la [NET. Conf 2018](http://netconfbcn2018.azurewebsites.net/) y varias personas no tenian conocimiento sobre ellos.

Los presentamos: 

- **S**ingle Responsability  
- **O**pen Closed 
- **L**iskow
- **I**nterface Segregation
- **D**ependency Injection

Los detallamos:

- **S**ingle Responsability

Este principio trata de destinar cada clase a una finalidad sencilla y concreta. En muchas ocasiones estamos tentados a poner un método reutilizable que no tienen nada que ver con la clase simplemente porque lo utiliza y nos pilla más a mano. En ese momento pensamos "Ya que estamos aquí, para que voy a crear una clase para realizar esto. Directamente lo pongo aquí".

El problema surge cuando tenemos la necesidad de utilizar ese mismo método desde otra clase. Si no se refactoriza en ese momento y se crea una clase destinada para la finalidad del método, nos toparemos a largo plazo con que las clases realizan tareas que no deberían ser de su responsabilidad.

Con la anterior mentalidad nos encontraremos, por ejemplo, con un algoritmo de formateo de números en una clase destinada a leer de la base de datos porque fue el primer sitio donde se empezó a utilizar. Esto conlleva a tener métodos difíciles de detectar y encontrar de manera que el código hay que tenerlo memorizado en la cabeza.

- **O**pen Closed 

Principio que habla de crear clases extensibles sin necesidad de entrar al código fuente a modificarlo. Es decir, el diseño debe ser abierto para poderse extender pero cerrado para poderse modificar. Aunque dicho parece fácil, lo complicado es predecir por donde se debe extender y que no tengamos que modificarlo. Para conseguir este principio hay que tener muy claro como va a funcionar la aplicación, por donde se puede extender y como van a interactuar las clases.

El uso más común de extensión es mediante la herencia y la reimplementación de métodos. Existe otra alternativa que consiste en utilizar métodos que acepten una interface de manera que podemos ejecutar cualquier clase que implemente ese interface. En todos los casos, el comportamiento de la clase cambia sin que hayamos tenido que tocar código interno.

Como ya he comentado llega un momento en que las necesidades pueden llegar a ser tan imprevisibles que nos topemos que con los métodos definidos en el interface o en los métodos extensibles, no sean suficientes para cubrir las necesidades. En este caso no habrá más remedio que romper este principio y refactorizar.

- **L**iskow

Este principio fue creado por Barbara Liskov y habla de la importancia de crear todas las clases derivadas para que también puedan ser tratadas como la propia clase base. Cuando creamos clases derivadas debemos asegurarnos de no reimplementar métodos que hagan que los métodos de la clase base no funcionases si se tratasen como un objeto de esa clase base.

- **I**nvterface Segretation

Este principio fue formulado por Robert C. Martin y trata de algo parecido al primer principio. Cuando se definen interfaces estos deben ser específicos a una finalidad concreta. Por ello, si tenemos que definir una serie de métodos abstractos que debe utilizar una clase a través de interfaces, es preferible tener muchos interfaces que definan pocos métodos que tener un interface con muchos métodos.

El objetivo de este principio es principalmente poder reaprovechar los interfaces en otras clases. Si tenemos un interface que compara y clona en el mismo interface, de manera más complicada se podrá utilizar en una clase que solo debe comparar o en otra que solo debe clonar.

- **D**ependency Injection

También fue definido por Robert C. Martin. El objetivo de este principio conseguir desacoplar las clases. En todo diseño siempre debe existir un acoplamiento pero hay que evitarlo en la medida de lo posible. Un sistema no acoplado no hace nada pero un sistema altamente acoplado es muy difícil de mantener.

El objetivo de este principio es el uso de abstracciones para conseguir que una clase interactue con otras clases sin que las conozca directamente. Es decir, las clases de nivel superior no deben conocer las clases de nivel inferior. Dicho de otro modo, no debe conocer los detalles. Existen diferentes patrones como la inyección de dependencias o service locator que nos permiten invertir el control.

Y como siempre un ejemplo donde veremos como vamos aplicando los principios. 

El problema

~~~csharp
using System;
namespace CalcToSolid
{
    public class NoSolidCalc
    {

        public int Operation(OperationType operationType, string operand1, string operand2)
        {

            var parsed1 =  int.TryParse(operand1, out int operandOneParsed);
            var parsed2 = int.TryParse(operand2, out int operandTwoParsed);

            if(parsed1 && parsed2){
                if (operationType.Equals(OperationType.DIV))
                {
                    return operandOneParsed / operandTwoParsed;
                }

                if (operationType.Equals(OperationType.MUL))
                {
                    return operandOneParsed * operandTwoParsed;
                }
                if (operationType.Equals(OperationType.SUB))
                {
                    return operandOneParsed - operandTwoParsed;
                }

                return operandOneParsed + operandTwoParsed;
            }
            return 0;
        }
    }

    public enum OperationType {
        SUM,
        SUB,
        DIV,
        MUL
    }
}


using System;

namespace CalcToSolid
{
    class Program
    {
        static void Main(string[] args)
        {
            NoSolidOperation();
        }

        private static void NoSolidOperation(){
            Console.WriteLine("Intro First Operand");
            var operand1 = Console.ReadLine();

            Console.WriteLine("Intro Second Operand");
            var operand2 = Console.ReadLine();

            Console.WriteLine("Intro Operation");
            Console.WriteLine("0: SUM");
            Console.WriteLine("1: SUB");
            Console.WriteLine("2: DIV");
            Console.WriteLine("3: MUL");
            var operation = (OperationType)Console.Read();

            var result = new NoSolidCalc().Operation(operation, operand1, operand2);
            Console.WriteLine(result);
        }
    }
}

~~~

La solución:

~~~csharp

namespace CalcToSolid.SolidCalc.Interfaces
{
    public interface ICalc
    {
        int DoOperation(OperationType operation, int operand1, int operand2);
    }
}

namespace CalcToSolid.SolidCalc.Interfaces
{
    public interface IConverter
    {
        int ConvertStringToInt(string value);
        float ConvertStringToFloat(string value); // Open-Close
    }
}

namespace CalcToSolid.SolidCalc.Interfaces
{
    public interface IMenu
    {
        string PrintMenuOperand1();
        string PrintMenuOperand2();
        OperationType PrintMenuOperation();
    }
}

namespace CalcToSolid.SolidCalc.Interfaces
{
    public interface IOperation 
    {
        int Execute(int operand1, int operand2);
    }
}

using CalcToSolid.SolidCalc.Interfaces;

namespace CalcToSolid.SolidCalc.Logic
{
    public class Converter : IConverter // Open - Close
    {
        int IConverter.ConvertStringToInt(string value) //Single responsibility
        {
            var isConverted = int.TryParse(value, out int intValue);
            return isConverted ? intValue : 0;
        }

        public float ConvertStringToFloat(string value) //  Single responsibility
        {
            var isConverted = float.TryParse(value, out float floatValue);
            return isConverted ? floatValue : 0.0f;
        }
    }
}

using System;
using CalcToSolid.SolidCalc.Interfaces;

namespace CalcToSolid.SolidCalc.Logic
{
    public class Menu : IMenu
    {
        private readonly IConverter _converter = new Converter();
        public string PrintMenuOperand1() //Single responsibility)
        {
            Console.WriteLine("Intro First Operand");
            return Console.ReadLine();
        }

        public string PrintMenuOperand2() //Single responsibility)
        {
            Console.WriteLine("Intro Second Operand");
            return Console.ReadLine();
        }

        public OperationType PrintMenuOperation() //Single responsibility)
        {
            Console.WriteLine("Intro Operation");
            Console.WriteLine("0: SUM");
            Console.WriteLine("1: SUB");
            Console.WriteLine("2: DIV");
            Console.WriteLine("3: MUL");
            Console.WriteLine("4: NExpM");
            var operation = Console.ReadLine();

            return (OperationType) _converter.ConvertStringToInt(operation);
        }
    }
}

using CalcToSolid.SolidCalc.Interfaces;

namespace CalcToSolid.SolidCalc.Logic
{
    public class OperationDiv : IOperation
    {
        public int Execute(int operand1, int operand2) //Single responsibility
        {
            return operand1 / operand2;
        }
    }
}

using CalcToSolid.SolidCalc.Interfaces;

namespace CalcToSolid.SolidCalc.Logic
{
	public class OperationMul : IOperation
    {
        public int Execute(int operand1, int operand2) //Single responsibility
        {
            return operand1 * operand2;
        }
    }
}

using CalcToSolid.SolidCalc.Interfaces;

namespace CalcToSolid.SolidCalc.Logic
{
    public class OperationNExpM : IOperation
    {
        private static readonly IOperation _mul = new OperationMul(); //Liskov 

        public int Execute(int operand1, int operand2)
        {
            int result= operand1;

            for (int i=1; i < operand2; i++)
            {
                result = _mul.Execute(result, operand1);
            }
            return result;
        }
    }
}

using CalcToSolid.SolidCalc.Interfaces;

namespace CalcToSolid.SolidCalc.Logic
{
    public class OperationSub : IOperation
    {
        public int Execute(int operand1, int operand2) //Single responsibility
        {
            return operand1 - operand2;
        }
    }
}

using CalcToSolid.SolidCalc.Interfaces;

namespace CalcToSolid.SolidCalc.Logic
{
    public class OperationSum : IOperation
    {
        public int Execute(int operand1, int operand2) //Single responsibility
        {
            return operand1 + operand2;
        }
    }
}

using CalcToSolid.SolidCalc.Interfaces;

namespace CalcToSolid.SolidCalc.Logic
{
    public class SolidCalc : ICalc
    {
        private readonly IOperation _summatory;
        private readonly IOperation _multiplication;
        private readonly IOperation _subtraction;
        private readonly IOperation _division;
        private readonly IOperation _exponential;

        public SolidCalc()
        {
            _summatory = new OperationSum(); //Interface segregation
            _multiplication = new OperationMul(); //Interface segregation
            _subtraction = new OperationSub(); //Interface segregation
            _division = new OperationDiv(); //Interface segregation
            _exponential = new OperationNExpM(); //Interface segregation
        }

        public int DoOperation(OperationType operation, int operand1, int operand2)
        {
            switch (operation)
            {
                case OperationType.Div:
                    return Division(operand1, operand2);
                case OperationType.Mul:
                    return Multiplication(operand1, operand2);
                case OperationType.Sub:
                    return Subtraction(operand1, operand2);
                case OperationType.Sum:
                    return Summatory(operand1, operand2);
                case OperationType.NExpM:
                    return Exponential(operand1, operand2);
                default:
                    return 0;
            }
        }

        private int Division(int operand1, int operand2)
        {
            return _division.Execute(operand1, operand2);
        }

        private int Multiplication(int operand1, int operand2)
        {
            return _multiplication.Execute(operand1, operand2);
        }

        private int Subtraction(int operand1, int operand2)
        {
            return _subtraction.Execute(operand1, operand2);
        }

        private int Summatory(int operand1, int operand2)
        {
            return _summatory.Execute(operand1, operand2);
        }

        private int Exponential(int operand1, int operand2)
        {
            return _exponential.Execute(operand1, operand2);
        }
    }
}
~~~

Un saludo.

> **Gracias:** A mis compañeros Erik Piqué, Marçal Montserrat y Omar Amalfi por sus comentarios.

> * En el repositorio vereís que ha varios commits con sus refactorizaciones hasta llegar a un estado final.

[Código de ejemplo](https://github.com/JRRN/EasySolidExercise/)