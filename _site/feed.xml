<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.0.0">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2020-01-01T12:24:19+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">JRRN Coding!</title><subtitle>Blog de desarrollo .NET personal. Contiene artículos técnicos de programación, arquitectura y desarrollo.</subtitle><author><name>JRRN</name><email></email></author><entry><title type="html">Backend for FrontEnds</title><link href="http://localhost:4000/backend-for-frontends" rel="alternate" type="text/html" title="Backend for FrontEnds" /><published>2020-01-01T00:00:00+01:00</published><updated>2020-01-01T00:00:00+01:00</updated><id>http://localhost:4000/backend-for-frontends</id><content type="html" xml:base="http://localhost:4000/backend-for-frontends">&lt;p&gt;¡Hola de nuevo! ¡Feliz año a todos! Hoy presentaremos el patrón de implementación Backends para Frontends. Este patrón está basado en el concepto “S” de SOLID de separación de responsabilidades.&lt;/p&gt;

&lt;p&gt;Lo que viene a decir es, teniendo una api que es consumida tanto por un aplicación móvil, cómo por una aplicación web deberiamos separar las llamadas que realiza la app mobil de las llamadas que realiza la aplicación web.&lt;/p&gt;

&lt;p&gt;Una imagen vale más que mil palabras:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/cloudpatterns/backforfront.png&quot; alt=&quot;Backend for Frontend&quot; title=&quot;Backend for Frontend&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Ahora, porqué esta aproximación es mucho mejor y coherente con nuestra infraestructura cloud?&lt;/p&gt;

&lt;p&gt;En primer lugar, teniendo separados los servicios, estos se pueden escalar independientemente según su tráfico.&lt;/p&gt;

&lt;p&gt;Por otro lado, aunque puedan tener llamadas iguales en nuestras apis, las dimensiones y cantidad de información a mostrar en cada dispositivo es diferente, con lo que nos señala que los modelos a devolver en nuestra llamadas son, en la parte web con muchas más propiedades y en la parte mobile, con muchas menos propiedades. Esta misma simplificación nos ayuda a reducir el peso de las llamadas en nuestros dispositivos móviles.&lt;/p&gt;

&lt;p&gt;Un saludos.&lt;/p&gt;</content><author><name>JRRN</name></author><category term="Arquitectura" /><summary type="html">¡Hola de nuevo! ¡Feliz año a todos! Hoy presentaremos el patrón de implementación Backends para Frontends. Este patrón está basado en el concepto “S” de SOLID de separación de responsabilidades.</summary></entry><entry><title type="html">Anti-Corruption Layer</title><link href="http://localhost:4000/anti-corruption-layer" rel="alternate" type="text/html" title="Anti-Corruption Layer" /><published>2019-12-29T00:00:00+01:00</published><updated>2019-12-29T00:00:00+01:00</updated><id>http://localhost:4000/anti-corruption-layer</id><content type="html" xml:base="http://localhost:4000/anti-corruption-layer">&lt;p&gt;Hola de nuevo. Lo primero, presta mucha atención a este patrón si estáis trabajando con microservicios o con Arquitecturas DDD (Domain Driven Design).&lt;/p&gt;

&lt;p&gt;Anti-Corruption Layer nos recomienda crear una capa de aislamiento que permita a los clientes trabajar con sus modelos de negocio y desacoplar estos modelos en nuestra lógica de negocio. Los sistemas se comunican entre ellos mediante los contratos establecidos (interfaces), y anti-corruption layer lo que nos proporciona es una mínima o nula modificación en las aplicaciones conectadas entre los sistemas. Internamente, la capa se traduce en ambas direcciones según sea necesario entre los dos modelos.&lt;/p&gt;

&lt;p&gt;Eric Evans, fue el que acuñó este concepto en su libro sobre &lt;a href=&quot;https://dddcommunity.org/book/evans_2003/&quot; title=&quot;Domain Driven Design&quot;&gt;DDD&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Así no reinventaremos la rueda y usaremos el ejemplo que usaba en su libro:&lt;/p&gt;

&lt;p&gt;Imaginemos que una aplicación depende de Google Calendar para programar y recordar eventos. Para sincronizar los datos desde y hacia Google Calendar, necesitaremos asignar los datos entre los dos sistemas, es decir, nuestra aplicación y Google Calendar. Esto se debe a que los modelos de datos y la estructura serán diferentes en estos sistemas. Con el patrón anti-corruption layer, lo que haremos es usar un proxy/middleware que traducza los contratos entre Google Calendar y los contratos que usemos en nuestra aplicaciones.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/cloudpatterns/anti-corruption-layer.png&quot; alt=&quot;Anti-Corruption Layer&quot; title=&quot;Anti-Corruption Layer&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Un saludo.&lt;/p&gt;</content><author><name>JRRN</name></author><category term="Arquitectura" /><summary type="html">Hola de nuevo. Lo primero, presta mucha atención a este patrón si estáis trabajando con microservicios o con Arquitecturas DDD (Domain Driven Design). Anti-Corruption Layer nos recomienda crear una capa de aislamiento que permita a los clientes trabajar con sus modelos de negocio y desacoplar estos modelos en nuestra lógica de negocio. Los sistemas se comunican entre ellos mediante los contratos establecidos (interfaces), y anti-corruption layer lo que nos proporciona es una mínima o nula modificación en las aplicaciones conectadas entre los sistemas. Internamente, la capa se traduce en ambas direcciones según sea necesario entre los dos modelos. Eric Evans, fue el que acuñó este concepto en su libro sobre DDD. Así no reinventaremos la rueda y usaremos el ejemplo que usaba en su libro: Imaginemos que una aplicación depende de Google Calendar para programar y recordar eventos. Para sincronizar los datos desde y hacia Google Calendar, necesitaremos asignar los datos entre los dos sistemas, es decir, nuestra aplicación y Google Calendar. Esto se debe a que los modelos de datos y la estructura serán diferentes en estos sistemas. Con el patrón anti-corruption layer, lo que haremos es usar un proxy/middleware que traducza los contratos entre Google Calendar y los contratos que usemos en nuestra aplicaciones. Un saludo.</summary></entry><entry><title type="html">Ambassador</title><link href="http://localhost:4000/ambassador" rel="alternate" type="text/html" title="Ambassador" /><published>2019-12-28T00:00:00+01:00</published><updated>2019-12-28T00:00:00+01:00</updated><id>http://localhost:4000/ambassador</id><content type="html" xml:base="http://localhost:4000/ambassador">&lt;p&gt;Hola! El patrón Ambassador nos sirve para colocar antes de otros servicios un “proxy” que nos de más control de comunicaciones sobre estas aplicaciones de terceros, pudiendo aplicar muchos de los patrones que estamos aprendiendo.&lt;/p&gt;

&lt;p&gt;Pongamos el caso, tenemos un servicio que nos devuelve las facturas de un usuario. Sin embargo, este servicio se codificó junto a las tablas de Moisés. Cada vez que abrimos ese código, en el caso de tenerlo, pensamos que lo mejor es rehacerlo porque no hay por donde meterle mano. Sin embargo, funciona tan bien que seguimos la regla “no sé cómo lo hace pero funciona, ni lo mires”. Sin embargo, necesitamos aplicar los patrones de valet key, throttling, circuit breaker y alguno más para adaptarnos a nuestra infraestructura.&lt;/p&gt;

&lt;p&gt;En este momento, entraría en juego nuestro patrón Ambassador, donde colocariamos un un servicio Proxy/Middleware entre el servicio de factoras y nuestra aplicaciones, donde, este middleware tendría aplicadas todas estas soluciones que presentábamos.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/cloudpatterns/ambassador.png&quot; alt=&quot;Ambassador&quot; title=&quot;Ambassador&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Saludos y hasta la próxima.&lt;/p&gt;</content><author><name>JRRN</name></author><category term="Arquitectura" /><summary type="html">Hola! El patrón Ambassador nos sirve para colocar antes de otros servicios un “proxy” que nos de más control de comunicaciones sobre estas aplicaciones de terceros, pudiendo aplicar muchos de los patrones que estamos aprendiendo. Pongamos el caso, tenemos un servicio que nos devuelve las facturas de un usuario. Sin embargo, este servicio se codificó junto a las tablas de Moisés. Cada vez que abrimos ese código, en el caso de tenerlo, pensamos que lo mejor es rehacerlo porque no hay por donde meterle mano. Sin embargo, funciona tan bien que seguimos la regla “no sé cómo lo hace pero funciona, ni lo mires”. Sin embargo, necesitamos aplicar los patrones de valet key, throttling, circuit breaker y alguno más para adaptarnos a nuestra infraestructura. En este momento, entraría en juego nuestro patrón Ambassador, donde colocariamos un un servicio Proxy/Middleware entre el servicio de factoras y nuestra aplicaciones, donde, este middleware tendría aplicadas todas estas soluciones que presentábamos. Saludos y hasta la próxima.</summary></entry><entry><title type="html">Valet Key</title><link href="http://localhost:4000/valet-key" rel="alternate" type="text/html" title="Valet Key" /><published>2019-12-27T00:00:00+01:00</published><updated>2019-12-27T00:00:00+01:00</updated><id>http://localhost:4000/valet-key</id><content type="html" xml:base="http://localhost:4000/valet-key">&lt;p&gt;Hola a todos. El patrón Valet Key nos ayuda a validar al usuario a la hora de acceder a contenido o recursos que no necesiten una autenticación de usuario, es decir, es ofrecer la posibilidad de consumir ciertos datos o recursos a usuarios anónimos que usan nuestra aplicación como pasarela para consumirlos.&lt;/p&gt;

&lt;p&gt;Vamos con el ejemplo.&lt;/p&gt;

&lt;p&gt;Imaginemos que tenemos una api en la que exponemos los resultados de fútbol de la jornada a los usuarios de nuestra aplicación. Nuestra aplicación front no requiere que el usuario esté registrado para poder saber los resultados de la jornada. La manera fácil, es crear un end point [anonymous] que devuelva estos resultados.&lt;/p&gt;

&lt;p&gt;Sin embargo, al realizar esta acción lo que estamos permitiendo es que cualquiera pueda realizar esta llamada, consumir nuestros servicio y por lo tanto tener un coste mayor de procesamiento ya que el diario deportivo mundial, se ha dado cuenta que este servicio lo puede consumir sin ningún coste adicional y obtener los resultados deportivos. Para nosotros, podría ser un problema si todos los forofos del fútbol del mundo están pendientes del resultado del partido más importante de la jornada. A final de mes, nos llevariamos una buena torta en la facturación de nuestra infraestructura por el coste de las llamadas, el escalado para aguantar el tráfico, etc…&lt;/p&gt;

&lt;p&gt;Sin embargo, con el patrón valet key, podemos mitigar este desafortunado incidente para nuestro bolsillo.&lt;/p&gt;

&lt;p&gt;Valet Key, lo que nos permite desde nuestra aplicación front es obtener un key con la que los usuarios anónimos podrán acceder al servicio de consulta de los resultados de la jornada, mientras lo realicen por la pasarela de nuestra aplicación. Mientras que si la llamada se origina fuera de nuestra aplicación, aseguraremos un 401.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/img/cloudpatterns/valet-key.png&quot; alt=&quot;Valet Key&quot; title=&quot;Valet Key&quot; /&gt;&lt;/p&gt;

&lt;p&gt;De esta forma, nuestro coste reflejará el consumo real de nuestros usuarios.&lt;/p&gt;

&lt;p&gt;Además, dando una vuelta más de tuerca, podremos dar keys que nos den información a nuestras aplicaciones back, para poder clasificar a estos usuarios en roles y según su rol, poder dar más o menos privilegios a estos usuario anónimos.&lt;/p&gt;

&lt;p&gt;Un saludo.&lt;/p&gt;</content><author><name>JRRN</name></author><category term="Arquitectura" /><summary type="html">Hola a todos. El patrón Valet Key nos ayuda a validar al usuario a la hora de acceder a contenido o recursos que no necesiten una autenticación de usuario, es decir, es ofrecer la posibilidad de consumir ciertos datos o recursos a usuarios anónimos que usan nuestra aplicación como pasarela para consumirlos. Vamos con el ejemplo. Imaginemos que tenemos una api en la que exponemos los resultados de fútbol de la jornada a los usuarios de nuestra aplicación. Nuestra aplicación front no requiere que el usuario esté registrado para poder saber los resultados de la jornada. La manera fácil, es crear un end point [anonymous] que devuelva estos resultados. Sin embargo, al realizar esta acción lo que estamos permitiendo es que cualquiera pueda realizar esta llamada, consumir nuestros servicio y por lo tanto tener un coste mayor de procesamiento ya que el diario deportivo mundial, se ha dado cuenta que este servicio lo puede consumir sin ningún coste adicional y obtener los resultados deportivos. Para nosotros, podría ser un problema si todos los forofos del fútbol del mundo están pendientes del resultado del partido más importante de la jornada. A final de mes, nos llevariamos una buena torta en la facturación de nuestra infraestructura por el coste de las llamadas, el escalado para aguantar el tráfico, etc… Sin embargo, con el patrón valet key, podemos mitigar este desafortunado incidente para nuestro bolsillo. Valet Key, lo que nos permite desde nuestra aplicación front es obtener un key con la que los usuarios anónimos podrán acceder al servicio de consulta de los resultados de la jornada, mientras lo realicen por la pasarela de nuestra aplicación. Mientras que si la llamada se origina fuera de nuestra aplicación, aseguraremos un 401. De esta forma, nuestro coste reflejará el consumo real de nuestros usuarios. Además, dando una vuelta más de tuerca, podremos dar keys que nos den información a nuestras aplicaciones back, para poder clasificar a estos usuarios en roles y según su rol, poder dar más o menos privilegios a estos usuario anónimos. Un saludo.</summary></entry><entry><title type="html">Static Content Hosting</title><link href="http://localhost:4000/static-content-hosting" rel="alternate" type="text/html" title="Static Content Hosting" /><published>2019-10-27T00:00:00+02:00</published><updated>2019-10-27T00:00:00+02:00</updated><id>http://localhost:4000/static-content-hosting</id><content type="html" xml:base="http://localhost:4000/static-content-hosting">&lt;p&gt;El objetivo de este patrón es reducir el coste de llamadas que no necesiten pasar por una lógica o servicio devolviendo el contenido o recurso requerido de la forma más rápida posible.&lt;/p&gt;

&lt;p&gt;Imaginemos que nuestra web tiene varios documentos PDF donde le explicamos al usuario como vamos a tratar su datos mientras los stalkeamos en su navegación por el site. Podríamos pensar que, cuando el usuario inicia esta solicitud, nos llama a la controller, voy al servicio que devuelve el contenido del pdf en base64 y que el navegador renderiza por las cabeceras en una nueva tab como pdf. Sí, ¿no? Pues no, justamente este patrón lo que nos recomienda es que le devolvamos el pdf desde la url del storage que apunta al pdf de gestion_datos.pdf.&lt;/p&gt;

&lt;p&gt;De esta forma, reducimos el procesamiento en nuestra/s instancia/s, que valen dinerito y usamos un storage que es más baratito.&lt;/p&gt;

&lt;p&gt;El truco, es pensar en este tipo de contenido y en su viabilidad de si sería aconsejable meterlo en un cdn.&lt;/p&gt;

&lt;p&gt;Saludos y hasta la próxima.&lt;/p&gt;</content><author><name>JRRN</name></author><category term="Arquitectura" /><summary type="html">El objetivo de este patrón es reducir el coste de llamadas que no necesiten pasar por una lógica o servicio devolviendo el contenido o recurso requerido de la forma más rápida posible. Imaginemos que nuestra web tiene varios documentos PDF donde le explicamos al usuario como vamos a tratar su datos mientras los stalkeamos en su navegación por el site. Podríamos pensar que, cuando el usuario inicia esta solicitud, nos llama a la controller, voy al servicio que devuelve el contenido del pdf en base64 y que el navegador renderiza por las cabeceras en una nueva tab como pdf. Sí, ¿no? Pues no, justamente este patrón lo que nos recomienda es que le devolvamos el pdf desde la url del storage que apunta al pdf de gestion_datos.pdf. De esta forma, reducimos el procesamiento en nuestra/s instancia/s, que valen dinerito y usamos un storage que es más baratito. El truco, es pensar en este tipo de contenido y en su viabilidad de si sería aconsejable meterlo en un cdn. Saludos y hasta la próxima.</summary></entry><entry><title type="html">Conferencia .NET Conf Barcelona 2019</title><link href="http://localhost:4000/netconfbarcelona" rel="alternate" type="text/html" title="Conferencia .NET Conf Barcelona 2019" /><published>2019-10-22T00:00:00+02:00</published><updated>2019-10-22T00:00:00+02:00</updated><id>http://localhost:4000/netconfbarcelona</id><content type="html" xml:base="http://localhost:4000/netconfbarcelona">&lt;p&gt;Hola a todos. Preparado para las .NET Conf Barcelona 2019 con Machine Learning .NET visión de aproximación.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://netconfbcn.azurewebsites.net/&quot;&gt;Site&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;&lt;strong&gt;Machine Learning .NET visión de aproximación:&lt;/strong&gt;
ML.Net es el nuevo framework de Microsoft que nos permite usar código c# en nuestros proyectos de Machine Learning. En esta charla profundizaremos un poquito, veremos sus características y una demo que permite reconocer objetos.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nos vemos en la conf.&lt;/p&gt;

&lt;p&gt;Saludos.&lt;/p&gt;</content><author><name>JRRN</name></author><category term="Conferences" /><summary type="html">Hola a todos. Preparado para las .NET Conf Barcelona 2019 con Machine Learning .NET visión de aproximación.</summary></entry><entry><title type="html">Sharding</title><link href="http://localhost:4000/sharding" rel="alternate" type="text/html" title="Sharding" /><published>2019-10-17T00:00:00+02:00</published><updated>2019-10-17T00:00:00+02:00</updated><id>http://localhost:4000/sharding</id><content type="html" xml:base="http://localhost:4000/sharding">&lt;p&gt;El patrón de Sharding o particionamiento es un patrón orientado a los datos; tiene especial consideración en la forma en que accedemos y almacenamos la información.&lt;/p&gt;

&lt;p&gt;La cuestión de todo esto es crear particiones de nuestros datos de forma distribuida en particiones. De esta forma, podremos balancear el acceso y recuperación de los datos de una forma más óptima accediendo al bloque al que estamos interesados. Por otro lado, esta misma técnica la podemos realizar particionando bases de datos extensas en bases de datos separadas y más pequeñas.&lt;/p&gt;

&lt;p&gt;Así, el escalado de las particiones es más rápido y podríamos escalar, como si fueran servicios independientes, las partes que necesitamos y en las que recurrimos más habitualmente a ellas.&lt;/p&gt;

&lt;p&gt;Venga en texto plano, ¿Qué es más manejable, una roca de 1 tonelada o 1000 rocas de 1 kilo? …&lt;/p&gt;

&lt;p&gt;Ahora transpolemos de esta pregunta las virtudes de este patrón.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Necesitaría ser un monstruo de máquina para mover la tonelada de piedra, mientras que en 1000 viajes, yo mismo, podría mover esa tonelada.&lt;/li&gt;
  &lt;li&gt;Si tuviera que mover dos veces la tonelada de datos, sería más fácil, que llamara a mi sobrina de 3 años y la liara por un par chucherías, que encontrar otro monstruo de máquina para mover la tonelada.&lt;/li&gt;
  &lt;li&gt;Podría repartir la tonelada de datos según las necesidades de las peticiones, de esta tonelada podría enviar el kilo que me solicita cada petición, mientras que si no lo tuviera particionado, tendría que llevar esa tonelada a la primera petición que tomara lo que necesita y seguidamente, llevar esa tonelada a la siguiente petición para que nuevamente, tomara lo que necesita.&lt;/li&gt;
  &lt;li&gt;Me sería más fácil hacer dos piedras de un kilo que dos piedras de una tonelada.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Parece sencillo verdad, sin embargo, la complejidad de este patrón, es tener muy claro el modelo de datos y saber que estrategia de particionado nos beneficia más en nuestra aplicación.&lt;/p&gt;

&lt;p&gt;Por ello según el tipo de particionado podemos encontrar las estrategias:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;De Búsqueda: Las entidades se organizan en particiones donde esta deberá contener todos los datos de la entidad buscada. Como ejemplo, si tuviéramos todos los libros del mundo con sus datos relacionados, significaría que deberíamos tener en la misma partición, con sus tablas relacionadas, los libros de Matilde Asensi en la tabla autores y la relacionada de sus libros. De esta forma, a la hora de buscar los libros de Matilde Asensi, no saltaríamos de partición para recuperar estos datos.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;De Rango: Las entidades directamente relacionadas, se agrupan en la misma partición y se ordenan por sus claves primarias. Como ejemplo podríamos particionar la base de datos de todos los libros del mundo según el apellido del autor, de esta forma accederíamos a particiones diferentes si buscamos un libro de Rice, Anne o un libro de Coates, Ta-Nemisi.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;De Hash: En este caso definimos un cálculo único para identificar en que partición almacenamos la información o la recuperamos. En el ejemplo de todos los libros del mundo, podríamos generar un hash a partir del nombre y apellidos de los autores:&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Autor&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Hash&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;Partición&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Anne Rice&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;41:6e:6e:65:20:52:69:63:65&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;9&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Matilde Asensi&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4d:61:74:69:6c:64:65:20:41:73:65:6e:73:69&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;14&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Ta-Nemisi Coates&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;54:61:2d:4e:65:6d:69:73:69:20:43:6f:61:74:65:73&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;16&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
Como se puede ver según nuestros requisitos, deberíamos tener muy presente cual de las estrategias se asimila a nuestro modelo de datos y cual deberíamos aplicar mejor.&lt;/p&gt;

&lt;p&gt;Un saludo y hasta la próxima.&lt;/p&gt;</content><author><name>JRRN</name></author><category term="Arquitectura" /><summary type="html">El patrón de Sharding o particionamiento es un patrón orientado a los datos; tiene especial consideración en la forma en que accedemos y almacenamos la información. La cuestión de todo esto es crear particiones de nuestros datos de forma distribuida en particiones. De esta forma, podremos balancear el acceso y recuperación de los datos de una forma más óptima accediendo al bloque al que estamos interesados. Por otro lado, esta misma técnica la podemos realizar particionando bases de datos extensas en bases de datos separadas y más pequeñas. Así, el escalado de las particiones es más rápido y podríamos escalar, como si fueran servicios independientes, las partes que necesitamos y en las que recurrimos más habitualmente a ellas. Venga en texto plano, ¿Qué es más manejable, una roca de 1 tonelada o 1000 rocas de 1 kilo? … Ahora transpolemos de esta pregunta las virtudes de este patrón. Necesitaría ser un monstruo de máquina para mover la tonelada de piedra, mientras que en 1000 viajes, yo mismo, podría mover esa tonelada. Si tuviera que mover dos veces la tonelada de datos, sería más fácil, que llamara a mi sobrina de 3 años y la liara por un par chucherías, que encontrar otro monstruo de máquina para mover la tonelada. Podría repartir la tonelada de datos según las necesidades de las peticiones, de esta tonelada podría enviar el kilo que me solicita cada petición, mientras que si no lo tuviera particionado, tendría que llevar esa tonelada a la primera petición que tomara lo que necesita y seguidamente, llevar esa tonelada a la siguiente petición para que nuevamente, tomara lo que necesita. Me sería más fácil hacer dos piedras de un kilo que dos piedras de una tonelada. Parece sencillo verdad, sin embargo, la complejidad de este patrón, es tener muy claro el modelo de datos y saber que estrategia de particionado nos beneficia más en nuestra aplicación. Por ello según el tipo de particionado podemos encontrar las estrategias: De Búsqueda: Las entidades se organizan en particiones donde esta deberá contener todos los datos de la entidad buscada. Como ejemplo, si tuviéramos todos los libros del mundo con sus datos relacionados, significaría que deberíamos tener en la misma partición, con sus tablas relacionadas, los libros de Matilde Asensi en la tabla autores y la relacionada de sus libros. De esta forma, a la hora de buscar los libros de Matilde Asensi, no saltaríamos de partición para recuperar estos datos. De Rango: Las entidades directamente relacionadas, se agrupan en la misma partición y se ordenan por sus claves primarias. Como ejemplo podríamos particionar la base de datos de todos los libros del mundo según el apellido del autor, de esta forma accederíamos a particiones diferentes si buscamos un libro de Rice, Anne o un libro de Coates, Ta-Nemisi. De Hash: En este caso definimos un cálculo único para identificar en que partición almacenamos la información o la recuperamos. En el ejemplo de todos los libros del mundo, podríamos generar un hash a partir del nombre y apellidos de los autores: Autor Hash Partición Anne Rice 41:6e:6e:65:20:52:69:63:65 9 Matilde Asensi 4d:61:74:69:6c:64:65:20:41:73:65:6e:73:69 14 Ta-Nemisi Coates 54:61:2d:4e:65:6d:69:73:69:20:43:6f:61:74:65:73 16 Como se puede ver según nuestros requisitos, deberíamos tener muy presente cual de las estrategias se asimila a nuestro modelo de datos y cual deberíamos aplicar mejor. Un saludo y hasta la próxima.</summary></entry><entry><title type="html">Materialized View</title><link href="http://localhost:4000/materialized-view" rel="alternate" type="text/html" title="Materialized View" /><published>2019-10-12T00:00:00+02:00</published><updated>2019-10-12T00:00:00+02:00</updated><id>http://localhost:4000/materialized-view</id><content type="html" xml:base="http://localhost:4000/materialized-view">&lt;p&gt;El patrón materialized view, nos sirve para tener datos fragmentados en diferentes tablas en una vista desnormalizada. De esta forma, podemos consultar estos datos y recuperarlos de una manera óptima.&lt;/p&gt;

&lt;p&gt;Vayamos al ejemplo para tener clara la situación y como este patrón nos ayuda a solucionarlo.&lt;/p&gt;

&lt;p&gt;Imaginemos que nuestra aplicación tiene la siguiente estrucutura:&lt;/p&gt;

&lt;p&gt;TABLA USUARIOS&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;(*) id_user&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;userName&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;userLastName&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pitufo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Gruñón&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Papá&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pitufo&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pitufo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Amoroso&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pitufo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Inteligente&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pitufo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Burlón&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;TABLA USUARIO CABELLERA&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;(*) id_cabellera&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;id_user&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;color&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;castaño&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;moreno&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;castaño&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;moreno&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;castaño&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Si quisieramos obtener el color de pelo de los usuarios deríamos hacer una join entre usuarios y cabellera. Imaginemos que, esta consulta fuera muy costosa. La solución pasa por tener una vista materializada precalculada, como si fuera una caché, con este resultado almacenado y simplemente ejecutar nuestra consulta sobre esta vista:&lt;/p&gt;

&lt;p&gt;VISTA USUARIO-CABELLERA&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;(*) id_user&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;userName&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;userLastName&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;id_cabellera&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;color&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pitufo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Gruñón&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;castaño&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Papá&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pitufo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;moreno&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pitufo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Amoroso&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;castaño&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pitufo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Inteligente&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;moreno&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pitufo&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Burlón&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;castaño&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Esta solución, nos brinda la capacidad de realizar esta acción de mejora en datos que no se actualizan con frecuencia. Si por el contrario, estos datos cambian constantemente, esto nos obligaría a recalcular o regenerar las vista y podría penalizarnos en vez de ayudarnos.&lt;/p&gt;

&lt;p&gt;Sin más, hasta la próxima.&lt;/p&gt;</content><author><name>JRRN</name></author><category term="Arquitectura" /><summary type="html">El patrón materialized view, nos sirve para tener datos fragmentados en diferentes tablas en una vista desnormalizada. De esta forma, podemos consultar estos datos y recuperarlos de una manera óptima. Vayamos al ejemplo para tener clara la situación y como este patrón nos ayuda a solucionarlo. Imaginemos que nuestra aplicación tiene la siguiente estrucutura: TABLA USUARIOS (*) id_user userName userLastName 1 Pitufo Gruñón 2 Papá Pitufo 3 Pitufo Amoroso 4 Pitufo Inteligente 5 Pitufo Burlón TABLA USUARIO CABELLERA (*) id_cabellera id_user color 1 1 castaño 2 2 moreno 3 3 castaño 4 4 moreno 5 5 castaño Si quisieramos obtener el color de pelo de los usuarios deríamos hacer una join entre usuarios y cabellera. Imaginemos que, esta consulta fuera muy costosa. La solución pasa por tener una vista materializada precalculada, como si fuera una caché, con este resultado almacenado y simplemente ejecutar nuestra consulta sobre esta vista: VISTA USUARIO-CABELLERA (*) id_user userName userLastName id_cabellera color 1 Pitufo Gruñón 1 castaño 2 Papá Pitufo 2 moreno 3 Pitufo Amoroso 3 castaño 4 Pitufo Inteligente 4 moreno 5 Pitufo Burlón 5 castaño Esta solución, nos brinda la capacidad de realizar esta acción de mejora en datos que no se actualizan con frecuencia. Si por el contrario, estos datos cambian constantemente, esto nos obligaría a recalcular o regenerar las vista y podría penalizarnos en vez de ayudarnos. Sin más, hasta la próxima.</summary></entry><entry><title type="html">Index Table</title><link href="http://localhost:4000/index-table" rel="alternate" type="text/html" title="Index Table" /><published>2019-10-03T00:00:00+02:00</published><updated>2019-10-03T00:00:00+02:00</updated><id>http://localhost:4000/index-table</id><content type="html" xml:base="http://localhost:4000/index-table">&lt;p&gt;El patrón Index Table se utiliza para crear índices secundarios sobre consultas, que la aplicación necesita, en campos que no son una primary key y así tener un acceso a los datos con una aceptable optimización.&lt;/p&gt;

&lt;p&gt;Situémonos, tenemos una tabla de productos, donde como es habitual, tenemos un id_producto como primary key, el campo nombre de producto, el tipo de producto y el precio.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;(*) id_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;tipo_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;precio&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Patatas&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Zanahorias&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Carne&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pescado&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Plátanos&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;Primary Key&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;En nuestra aplicación para buscar patatas ejecutaríamos la query:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * from TABLE Where id_producto = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Con lo que obtendríamos con un buen rendimiento:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;(*) id_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;tipo_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;precio&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Patatas&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Sin embargo, no siempre tenemos porque conocer el identificador de lo que estamos buscando en base de datos y esto nos penaliza si buscamos por “Patatas”.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * from TABLE Where producto = &quot;Patatas&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;A pesar de que lo encuentra, si tuviéramos una base de datos con bastante peso, esta query podría penalizar al rendimiento de la aplicación o incluso darnos un timeout en la query, cosa que no sería necesario si implementáramos Index Table.&lt;/p&gt;

&lt;p&gt;Aunque existen motores de bases de datos, SQL Server lo permite, en los que puedes crear índices secundarios, puede ser una buena práctica no crear estos índices y usar este patrón. Por otro lado, para aquellos motores NO-SQL en los que los índices “no existen” (lo pongo entre comillas antes de que os tiréis al cuello) este patrón se ajusta bastante bien.&lt;/p&gt;

&lt;p&gt;Al lío.&lt;/p&gt;

&lt;p&gt;Tenemos varias estrategias según cuantos índices secundarios necesitamos:&lt;/p&gt;

&lt;p&gt;La primera de ellas (romper la 1ª Forma Normal, 2ªFN, 3ªFN …), recomendable cuando nuestros datos no se actualizan con frecuencia, duplicando la tabla pero cambiando la primary key:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;(*) producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;id_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;tipo_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;precio&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Patatas&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Zanahorias&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Carne&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pescado&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Plátanos&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Si volviéramos a ejecutar la consulta:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;SELECT * from TABLE_PRODUCT_NAME Where producto = &quot;Patatas&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;El rendimiento de nuestra query estaría optimizado.&lt;/p&gt;

&lt;p&gt;La segunda estrategia sería crear tablas con referencias a otras tablas formalizadas con los índices secundarios. Más vale un a imagen que mil palabras:&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;(*) id_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;tipo_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;precio&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Patatas&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Zanahorias&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Carne&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pescado&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Plátanos&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;relación (*)id_producto = id_producto&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;(*) producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;id_producto&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Patatas&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Zanahorias&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Carne&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pescado&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Plátanos&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;De esta forma si quisiéramos obtener el precio de las patatas:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;@Id = SELECT id  from TABLE_PRODUCTS_NAME WHERE producto = &quot;Patatas&quot;
SELECT prices from TABLE_PRODUCTS WHERE id = &quot;@Id&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Lo malo, sí, como vemos tenemos que tirar dos queries. ¿¿Y la JOIN?? Pensad en grandes bases de datos…&lt;/p&gt;

&lt;p&gt;La tercera estrategía, es una mezcla entre la primera y la segunda, es decir, duplicar… las tablas normalizadas pero con los índices que queramos y en función de la SELECT hacer un switch a la tabla que contiene el índice por el WHERE que estamos buscando:&lt;/p&gt;

&lt;p&gt;TABLE PRIMARY KEY PRODUCT_ID&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;(*) id_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;tipo_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;precio&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Patatas&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Zanahorias&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Carne&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pescado&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Plátanos&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;TABLE PRIMARY KEY PRODUCT_NAME&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;(*) producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;id_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;tipo_producto&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;precio&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Patatas&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Zanahorias&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;1&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Carne&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;2&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;6&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Pescado&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Plátanos&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;5&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;4&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;3&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Que buscamos “Patatas” pues atacamos a TABLE PRIMARY KEY PRODUCT_NAME, en cambio si buscamos por id atacaremos a TABLE PRIMARY KEY PRODUCT_ID.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Si buscáramos por nombre de producto y por tipo de producto una solución es crear una tabla concatenado los estos parámetros como clave primaria en la tabla resultante TABLE PRIMARY KEY PRODUCT_NAME+PRODUCT_TYPE.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Un saludo.&lt;/p&gt;</content><author><name>JRRN</name></author><category term="Arquitectura" /><summary type="html">El patrón Index Table se utiliza para crear índices secundarios sobre consultas, que la aplicación necesita, en campos que no son una primary key y así tener un acceso a los datos con una aceptable optimización. Situémonos, tenemos una tabla de productos, donde como es habitual, tenemos un id_producto como primary key, el campo nombre de producto, el tipo de producto y el precio. (*) id_producto producto tipo_producto precio 1 Patatas 1 2 2 Zanahorias 1 3 3 Carne 2 6 4 Pescado 3 5 5 Plátanos 4 3 Primary Key En nuestra aplicación para buscar patatas ejecutaríamos la query: SELECT * from TABLE Where id_producto = 1 Con lo que obtendríamos con un buen rendimiento: (*) id_producto producto tipo_producto precio 1 Patatas 1 2 Sin embargo, no siempre tenemos porque conocer el identificador de lo que estamos buscando en base de datos y esto nos penaliza si buscamos por “Patatas”. SELECT * from TABLE Where producto = &quot;Patatas&quot; A pesar de que lo encuentra, si tuviéramos una base de datos con bastante peso, esta query podría penalizar al rendimiento de la aplicación o incluso darnos un timeout en la query, cosa que no sería necesario si implementáramos Index Table. Aunque existen motores de bases de datos, SQL Server lo permite, en los que puedes crear índices secundarios, puede ser una buena práctica no crear estos índices y usar este patrón. Por otro lado, para aquellos motores NO-SQL en los que los índices “no existen” (lo pongo entre comillas antes de que os tiréis al cuello) este patrón se ajusta bastante bien. Al lío. Tenemos varias estrategias según cuantos índices secundarios necesitamos: La primera de ellas (romper la 1ª Forma Normal, 2ªFN, 3ªFN …), recomendable cuando nuestros datos no se actualizan con frecuencia, duplicando la tabla pero cambiando la primary key: (*) producto id_producto tipo_producto precio Patatas 1 1 2 Zanahorias 2 1 3 Carne 3 2 6 Pescado 4 3 5 Plátanos 5 4 3 Si volviéramos a ejecutar la consulta: SELECT * from TABLE_PRODUCT_NAME Where producto = &quot;Patatas&quot; El rendimiento de nuestra query estaría optimizado. La segunda estrategia sería crear tablas con referencias a otras tablas formalizadas con los índices secundarios. Más vale un a imagen que mil palabras: (*) id_producto producto tipo_producto precio 1 Patatas 1 2 2 Zanahorias 1 3 3 Carne 2 6 4 Pescado 3 5 5 Plátanos 4 3 relación (*)id_producto = id_producto (*) producto id_producto Patatas 1 Zanahorias 2 Carne 3 Pescado 4 Plátanos 5 De esta forma si quisiéramos obtener el precio de las patatas: @Id = SELECT id from TABLE_PRODUCTS_NAME WHERE producto = &quot;Patatas&quot; SELECT prices from TABLE_PRODUCTS WHERE id = &quot;@Id&quot; Lo malo, sí, como vemos tenemos que tirar dos queries. ¿¿Y la JOIN?? Pensad en grandes bases de datos… La tercera estrategía, es una mezcla entre la primera y la segunda, es decir, duplicar… las tablas normalizadas pero con los índices que queramos y en función de la SELECT hacer un switch a la tabla que contiene el índice por el WHERE que estamos buscando: TABLE PRIMARY KEY PRODUCT_ID (*) id_producto producto tipo_producto precio 1 Patatas 1 2 2 Zanahorias 1 3 3 Carne 2 6 4 Pescado 3 5 5 Plátanos 4 3 TABLE PRIMARY KEY PRODUCT_NAME (*) producto id_producto tipo_producto precio Patatas 1 1 2 Zanahorias 2 1 3 Carne 3 2 6 Pescado 4 3 5 Plátanos 5 4 3 Que buscamos “Patatas” pues atacamos a TABLE PRIMARY KEY PRODUCT_NAME, en cambio si buscamos por id atacaremos a TABLE PRIMARY KEY PRODUCT_ID. Si buscáramos por nombre de producto y por tipo de producto una solución es crear una tabla concatenado los estos parámetros como clave primaria en la tabla resultante TABLE PRIMARY KEY PRODUCT_NAME+PRODUCT_TYPE. Un saludo.</summary></entry><entry><title type="html">Event Sourcing</title><link href="http://localhost:4000/event-sourcing" rel="alternate" type="text/html" title="Event Sourcing" /><published>2019-09-24T00:00:00+02:00</published><updated>2019-09-24T00:00:00+02:00</updated><id>http://localhost:4000/event-sourcing</id><content type="html" xml:base="http://localhost:4000/event-sourcing">&lt;p&gt;El patrón Event Sourcing nos ayuda con el diseño y la implementación de nuestra aplicación. Es un patrón que se basa en almacenar todos lo cambios realizados sobre una entidad de dominio.&lt;/p&gt;

&lt;p&gt;Este patrón nos ayuda a saber porque estados a pasado una entidad y en caso de producirse un fallo irrecuperable, poder reprocesar los estados almacenados dejando la estructura de datos de nuevo con el último estado que tenía (mantener la coherencia de datos) o realizar modificaciones manuales para compensar algún error, a través de un evento.&lt;/p&gt;

&lt;p&gt;Este patrón nos ayuda a mitigar los problemas de las arquitecturas CRUD con muchas peticiones concurrentes.&lt;/p&gt;

&lt;p&gt;Imaginemos que tenemos 2 usuarios (A, B) que van a interactuar con una misma entidad, y que por cosas del espacio-tiempo las dos transacciones llegan al mismo tiempo a la base de datos para modificar esta entidad. Podría ser, que por mala fortuna, la petición B que debería procesarse posterior a la de A, modifique la entidad y que seguidamente A la volviera a modificar. En este caso obtendríamos una inconsistencia de datos en esa entidad, con lo que la veracidad de la información quedaría anulada.&lt;/p&gt;

&lt;p&gt;Con event sourcing, podemos solventar este problema, ya que los eventos de A y B tienen una marca de tiempo, con lo que nos permite procesar estos eventos cronológicamente como sucede con los &lt;a href=&quot;https://es.wikipedia.org/wiki/Tiempos_lógicos_de_Lamport&quot; title=&quot;Relojes de Lamport&quot;&gt;Relojes de Lamport&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Los principales beneficios de Event Sourcing son:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Almacenamos todos los eventos que hacen mutar una entidad.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Como la emisión y el procesamiento de los eventos van por separado, nos permite mejor rendimiento y escalabilidad.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Tenemos una trazabilidad para verificar, modificar o eliminar cambios en una entidad y sabemos quien y cuando se ha desencadenado este evento.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Mejoramos la consistencias de datos ya que no se producen modificaciones simultaneas sin controlar el orden en nuestra base de datos.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Casa muy bien con el patrón CQRS.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Veamos el gráfico de la infraestructura:&lt;/p&gt;</content><author><name>JRRN</name></author><category term="Arquitectura" /><summary type="html">El patrón Event Sourcing nos ayuda con el diseño y la implementación de nuestra aplicación. Es un patrón que se basa en almacenar todos lo cambios realizados sobre una entidad de dominio.</summary></entry></feed>