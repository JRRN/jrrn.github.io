I"Ω<p>Hola de nuevo, hoy quiero hablaros de la cach√© no distribuida que nos aporta Net Core y que la carga en memoria.</p>

<p>Este tipo de cach√©, como redis, memcach√©, etc‚Ä¶ se diferencia que no es una cach√© persistida y distribuida. Esto quiere decir que esta cach√© se crea en memoria y en cada instancia de servidor de la aplicaci√≥n, donde tenemos una cach√© diferente.</p>

<p>Para ello, simplemente necesitamos a√±adir el servicio en la inyecci√≥n de dependencias y el paquete nuget <strong>Microsoft.Extensions.Caching.Memory</strong>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">void</span> <span class="nf">ConfigureServices</span><span class="p">(</span><span class="n">IServiceCollection</span> <span class="n">services</span><span class="p">)</span>
<span class="p">{</span>
    <span class="p">...</span>
    <span class="n">services</span><span class="p">.</span><span class="nf">AddMemoryCache</span><span class="p">();</span>
    <span class="p">...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Inyectado nuestro servicio, ahora ya podemos usar la Interfaz IMemoryCache y generar cach√©s de nuestros servicios:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">class</span> <span class="nc">NuestroController</span> <span class="p">:</span> <span class="n">Controller</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">IMemoryCache</span> <span class="n">_cache</span><span class="p">;</span>
    <span class="k">private</span> <span class="n">IUserRepository</span> <span class="n">_userRepository</span><span class="p">;</span>

    <span class="k">public</span> <span class="nf">NuestroController</span><span class="p">(</span><span class="n">IMemoryCache</span> <span class="n">memoryCache</span><span class="p">,</span>
                             <span class="n">IUserRepository</span> <span class="n">userRepository</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">_cache</span> <span class="p">=</span> <span class="n">memoryCache</span><span class="p">;</span>
        <span class="n">_userRepository</span> <span class="p">=</span> <span class="n">userRepository</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="p">[</span><span class="n">HttpGet</span><span class="p">]</span>
    <span class="k">public</span> <span class="k">async</span> <span class="n">Task</span><span class="p">&lt;</span><span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">Usuarios</span><span class="p">&gt;&gt;</span> <span class="nf">GetUsersByCountry</span><span class="p">(</span><span class="kt">string</span> <span class="n">country</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">var</span> <span class="n">cacheKey</span> <span class="p">=</span> <span class="s">$"users-</span><span class="p">{</span><span class="n">country</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
        <span class="kt">var</span> <span class="n">users</span> <span class="p">=</span>  <span class="k">await</span> <span class="n">_cache</span><span class="p">.</span><span class="nf">GetOrCreateAsync</span><span class="p">(</span><span class="n">cacheKey</span><span class="p">,</span> <span class="n">entry</span> <span class="p">=&gt;</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">await</span> <span class="n">_userRepository</span><span class="p">.</span><span class="nf">GetUsersByCountry</span><span class="p">(</span><span class="n">country</span><span class="p">);</span>
        <span class="p">});</span>
        <span class="k">return</span> <span class="n">users</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Y voil√†, ya tenemos una cach√© montada en memoria. La cach√© que se forma, es usuarios por pa√≠s. As√≠, si en la primera llamada pedimos los usuarios de Espa√±a, accederemos hasta el repositorio, nos traeremos los datos y en la salida crear√° una cach√© con la clave users-es con los usuarios de Espa√±a. Si volvemos a ejecutar la llamada al controller, la llamada ya no bajar√° hasta el repository sino que ser√° la cach√© quien nos devuelva los usuarios. Sin embargo, si solicitamos los usuarios de M√©xico, se volver√° el acceder al repositorio y se a√±adir√° a la cach√© de usuarios con la clave users-mx.</p>

<p>Vale, ¬øque f√°cil no? Pues la verdad que s√≠. Decir que la IMemoryCach√© se limita por un <a href="https://es.wikipedia.org/wiki/Algoritmo_de_cach√©">algoritmo LRU</a> que nos permite usar el 20% de la RAM de la instancia como m√°ximo.</p>

<p>Este tipo de cach√© funciona hasta que se llena. Es decir si nos ligit adamos a pedir usuarios de pa√≠ses se generaran tantas cachekeys como nos quepan en ese 20%. Las dem√°s ir√°n a repositorio mientras no entre a funcionar el algoritmo LRU.</p>

<p>Ooooooooh!!! Pero tranquis, que es configurable.</p>

<p>Seteamos la vida de la cach√©, FromSeconds; FromMinutes‚Ä¶, con esta propiedad la cach√© se destruye en x tiempo:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">users</span> <span class="p">=</span>  <span class="k">await</span> <span class="n">_cache</span><span class="p">.</span><span class="nf">GetOrCreateAsync</span><span class="p">(</span><span class="n">cacheKey</span><span class="p">,</span> <span class="n">entry</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">entry</span><span class="p">.</span><span class="n">SlidingExpiration</span> <span class="p">=</span> <span class="n">TimeSpan</span><span class="p">.</span><span class="nf">FromMinutes</span><span class="p">(</span><span class="m">60</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">_userRepository</span><span class="p">.</span><span class="nf">GetUsersByCountry</span><span class="p">(</span><span class="n">country</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Seteamos la capacidad de la cach√© a 50 megas <strong>ojito con los c√°lculos a ojo cubero que nos podemos comer la memoria si nuestro equipo empieza a crear caches en los diferentes servicios sin control</strong>:</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">users</span> <span class="p">=</span>  <span class="k">await</span> <span class="n">_cache</span><span class="p">.</span><span class="nf">GetOrCreateAsync</span><span class="p">(</span><span class="n">cacheKey</span><span class="p">,</span> <span class="n">entry</span> <span class="p">=&gt;</span>
<span class="p">{</span>
    <span class="n">entry</span><span class="p">.</span><span class="n">Size</span> <span class="p">=</span> <span class="m">50</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">await</span> <span class="n">_userRepository</span><span class="p">.</span><span class="nf">GetUsersByCountry</span><span class="p">(</span><span class="n">country</span><span class="p">);</span>
<span class="p">});</span>
</code></pre></div></div>

<p>Y de momento eso es todo.</p>

<p>Un saludo y hasta la pr√≥xima.</p>
:ET